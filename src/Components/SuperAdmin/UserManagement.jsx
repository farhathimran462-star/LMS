import React, { useState, useEffect, useRef, useMemo } from "react";
import {
  FiSearch,
  FiFilter,
  FiX,
  FiEdit2,
  FiTrash2,
  FiPlus,
  FiAlertTriangle, 
  FiCheckCircle,   
} from "react-icons/fi";
import { MdBlock } from "react-icons/md";
import { RiUserForbidFill } from "react-icons/ri";
import { HiUserCircle } from "react-icons/hi";
import "../../Styles/SuperAdmin/UserManagement.css";
import DynamicTable from "../Reusable/DynamicTable";
import DynamicForm from "../Reusable/DynamicForm"; 
import { 
  getAllUsers, 
  createStudent, 
  createTeacher, 
  createAdmin, 
  createSuperAdmin, 
  deleteUser,
  updateStudent,
  updateTeacher,
  updateAdmin,
  updateSuperAdmin,
  getStudentByUserId,
  getTeacherByUserId,
  getAdminByUserId,
  getSuperAdminByUserId,
  updateUserSuspension,
  reactivateUser
} from '../../api/usersApi';
import { getAllInstitutions } from '../../api/institutionsApi'; 

// ⚠️ IMPORTANT: Set the API Base URL
const API_BASE_URL = "http://localhost:5000/api";

// --- COLUMN DEFINITION FOR DYNAMICTABLE ---
// Base columns shown for all roles
const BASE_USER_COLUMNS = [
    'full_name',
    'username',
    'email',
    'role',
    'phone'
];

// Function to get dynamic columns based on selected role
const getUserColumns = (selectedRole) => {
    const baseColumns = [...BASE_USER_COLUMNS];
    
    // If no role selected, null, or empty string, show only base columns
    if (!selectedRole || selectedRole === '' || selectedRole === 'All Roles' || selectedRole === null) {
        return baseColumns;
    }
    
    // Add role-specific columns
    let columns;
    switch (selectedRole.toLowerCase()) {
        case 'student':
            columns = [...baseColumns, 'roll_number', 'institute_name'];
            return columns;
        case 'admin':
            columns = [...baseColumns, 'employee_id', 'managed_institutes'];
            return columns;
        case 'teacher':
        case 'super admin':
        case 'superadmin':
            columns = [...baseColumns, 'employee_id'];
            return columns;
        default:
            return baseColumns;
    }
};

const PENDING_USER_COLUMN_ORDER = [
    'username',
    'fullName',
    'email',
    'phone',
    'role',
    'status',
];

// --- CONSTANTS FOR DROPDOWNS ---
const INSTITUTE_OPTIONS = [
    { label: 'Career Point - Chennai', value: 'CP_Chennai' },
    { label: 'Career Point - Mumbai', value: 'CP_Mumbai' },
    { label: 'Career Point - Delhi', value: 'CP_Delhi' },
];

const COURSE_OPTIONS = [
    { label: 'Physics', value: 'Physics' },
    { label: 'Chemistry', value: 'Chemistry' },
    { label: 'Maths', value: 'Maths' },
    { label: 'Biology', value: 'Biology' },
    { label: 'English', value: 'English' },
    { label: 'Computer Science', value: 'CS' },
];

// --- NEW OPTIONS FOR STUDENT FIELDS ---
const LEVEL_OPTIONS = [
    { label: 'Level 1 (Beginner)', value: 'L1' },
    { label: 'Level 2 (Intermediate)', value: 'L2' },
    { label: 'Level 3 (Advanced)', value: 'L3' },
];

const PROGRAMME_OPTIONS = [
    { label: 'Regular Programme', value: 'Regular' },
    { label: 'Weekend Programme', value: 'Weekend' },
    { label: 'Crash Course', value: 'Crash' },
];

const BATCH_OPTIONS = [
    { label: 'Batch A - 2025', value: '2025_A' },
    { label: 'Batch B - 2025', value: '2025_B' },
    { label: 'Batch C - 2026', value: '2026_C' },
];

const CLASS_OPTIONS = [
    { label: 'Class 10-A', value: '10A' },
    { label: 'Class 10-B', value: '10B' },
    { label: 'Class 11-A', value: '11A' },
    { label: 'Class 12-A', value: '12A' },
];

// --- HELPER: Generate DynamicForm Config based on Role ---
const getUserRoleConfig = (role, instituteOptions = [], isEditMode = false) => {
    // 1. Common Fields for ALL roles (stored in Users table)
    const baseFields = [
        { 
            name: 'full_name', 
            label: 'Full Name', 
            type: 'text-enter', 
            required: true, 
            fullWidth: true,
            hintText: "Enter the user's legal first and last name."
        },
        { 
            name: 'email', 
            label: 'Email Address', 
            type: 'text-enter', 
            required: true,
            hintText: "Official email address."
        },
        { 
            name: 'phone', 
            label: 'Phone Number', 
            type: 'text-enter', 
            required: true,
            numberLimit: 10 
        },
        { 
            name: 'username', 
            label: 'Username', 
            type: 'text-enter', 
            required: true,
            autogeneratedMethod: (prevValue) => {
               return prevValue ? prevValue.toLowerCase().replace(/\s+/g, '.') : '';
            },
            hintText: "System generated or custom username."
        },
        { 
            name: 'password', 
            label: 'Password', 
            type: 'text-enter',
            required: !isEditMode, // Password not required when editing
            hintText: isEditMode ? "Leave blank to keep existing password" : "Default password for the user."
        },
    ];

    // 2. Role Specific Fields
    let specificFields = [];

    switch (role) {
        case 'Student':
            specificFields = [
                { 
                    name: 'roll_number', 
                    label: 'Roll Number', 
                    type: 'text-enter', 
                    required: true 
                },
                { 
                    name: 'institute', 
                    label: 'Institute', 
                    type: 'single-select', 
                    options: instituteOptions,
                    required: true 
                }
            ];
            break;

        case 'Teacher':
            specificFields = [
                { 
                    name: 'employee_id', 
                    label: 'Employee ID', 
                    type: 'text-enter', 
                    required: true 
                }
            ];
            break;

        case 'Admin':
            specificFields = [
                { 
                    name: 'employee_id', 
                    label: 'Employee ID', 
                    type: 'text-enter', 
                    required: true 
                },
                { 
                    name: 'institutes_managed', 
                    label: 'Institutes Managed', 
                    type: 'multi-select', 
                    options: instituteOptions,
                    required: true,
                    fullWidth: true
                }
            ];
            break;

        case 'Super Admin':
            specificFields = [
                { 
                    name: 'employee_id', 
                    label: 'Employee ID', 
                    type: 'text-enter', 
                    required: true 
                }
            ];
            break;

        default:
            break;
    }

    // 3. Status and Suspension Fields (common for all)
    const statusFields = [
        { 
            name: 'is_active', 
            label: 'Account Status', 
            type: 'single-select', 
            options: [
                { label: 'Active', value: true }, 
                { label: 'Suspended', value: false }
            ],
            required: true
        },
        { 
            name: 'suspension_reason', 
            label: 'Suspension Reason', 
            type: 'text-enter', 
            fullWidth: true,
            hintText: "Only required if Status is Suspended."
        },
        { 
            name: 'suspension_start', 
            label: 'Suspension Start', 
            type: 'date-start' 
        },
        { 
            name: 'suspension_end', 
            label: 'Suspension End', 
            type: 'date-end' 
        },
        { 
            name: 'notes', 
            label: 'Notes / Remarks', 
            type: 'text-enter', 
            fullWidth: true 
        }
    ];

    return [...baseFields, ...specificFields, ...statusFields];
};


// --- SuspendUserModal ---
const SuspendUserModal = ({ user, onClose, onSave }) => {
  const isSuspended = user.is_active === false;
  const [reason, setReason] = useState(user.suspensionReason || "");
  const [startDate, setStartDate] = useState("");
  const [endDate, setEndDate] = useState("");
  const [showConfirm, setShowConfirm] = useState(false); 

  useEffect(() => {
  }, [user]);

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!isSuspended && !reason.trim()) {
        alert("Suspension reason is required.");
        return;
    }
    setShowConfirm(true); 
  };

  const handleConfirmAction = () => {
    setShowConfirm(false); 
    const payload = {
      user_id: user.user_id,
      action: isSuspended ? "reactivate" : "suspend",
      reason: isSuspended ? "" : reason, 
      timeline: { startDate, endDate }
    };
    onSave(payload); 
    onClose(); 
  };

  if (showConfirm) {
    return (
        <div className="modal-overlay">
            <div className="modal-content small-modal">
                <h3 className="modal-title">Confirm {isSuspended ? "Reactivation" : "Suspension"}</h3>
                <p>Are you sure you want to {isSuspended ? "REACTIVATE" : "SUSPEND"} the user **{user.username}**?</p>
                <div className="modal-actions">
                    <button className="btn btn-outline" onClick={() => setShowConfirm(false)}>Cancel</button>
                    <button className={`btn ${isSuspended ? "btn-primary" : "btn-danger"}`} onClick={handleConfirmAction}>
                        {isSuspended ? "Confirm Reactivate" : "Confirm Suspend"}
                    </button>
                </div>
            </div>
        </div>
    );
  }

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <div className="modal-header">
          <h3 className="modal-title">{isSuspended ? "Reactivate User" : "Suspend User"}</h3>
          <FiX className="close-icon" onClick={onClose} />
        </div>
        <form onSubmit={handleSubmit} className="modal-form">
          <p className="user-info-text">User: {user.fullName}  - {user.role}</p>
          {!isSuspended && (
            <>
              <div className="form-group">
                <label htmlFor="reason">Reason for Suspension <span className="required">*</span></label>
                <textarea id="reason" rows="3" value={reason} onChange={(e) => setReason(e.target.value)} required placeholder="Enter reason..." />
              </div>
              <div className="form-group-row">
                <div className="form-group">
                  <label htmlFor="startDate">Start Date</label>
                  <input id="startDate" type="date" value={startDate} onChange={(e) => setStartDate(e.target.value)} />
                </div>
                <div className="form-group">
                  <label htmlFor="endDate">End Date (Optional)</label>
                  <input id="endDate" type="date" value={endDate} onChange={(e) => setEndDate(e.target.value)} />
                </div>
              </div>
            </>
          )}
          <div className="modal-actions">
            <button type="button" className="btn btn-outline" onClick={onClose}>Cancel</button>
            <button type="submit" className={`btn btn-primary`}>{isSuspended ? "Reactivate User" : "Suspend User"}</button>
          </div>
        </form>
      </div>
    </div>
  );
};


const UserManagement = () => {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState("");
  const [selectedUsers, setSelectedUsers] = useState([]);
  const [selectedRole, setSelectedRole] = useState(null); 
  const [filters, setFilters] = useState({
    role: null,
    status: null,
    batch: null,
    institution: null,
  });

  const [availableBatches, setAvailableBatches] = useState([]);
  const [institutions, setInstitutions] = useState([]);
  // eslint-disable-next-line no-unused-vars
  const filterRef = useRef(null); 

  const [editUser, setEditUser] = useState(null);
  // eslint-disable-next-line no-unused-vars
  const [formSource, setFormSource] = useState(null);

  const [suspendPopup, setSuspendPopup] = useState({ open: false, user: null });
  // eslint-disable-next-line no-unused-vars
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(null);
  
  const [pendingUsers, setPendingUsers] = useState([]);

  // Transform institutions into options format
  const instituteOptions = useMemo(() => {
    return institutions.map(inst => ({
      label: inst.institution_name || inst.institute_name || inst.name || 'Unknown',
      value: inst.institute_id  // Always use institute_id for consistency
    }));
  }, [institutions]);

  // Fetch real users and institutions
  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      
      // Fetch real institutions
      const { data: institutionsData } = await getAllInstitutions();
      setInstitutions(institutionsData || []);
      
      // Fetch all users from database
      const { data: usersData, error } = await getAllUsers();
      if (error) {
        setError('Failed to fetch users: ' + error.message);
        setLoading(false);
        return;
      }
      
      // Transform users data for display
      const transformedUsers = (usersData || []).map(user => ({
        user_id: user.user_id,
        username: user.username,
        fullName: user.full_name,
        full_name: user.full_name,
        email: user.email,
        phone: user.phone,
        role: user.role,
        is_active: user.is_active,
        status: user.is_active ? 'Active' : 'Suspended',
        last_login: user.last_login,
        suspensionReason: user.suspension_reason,
        notes: user.notes,
        // Role-specific fields
        roll_number: user.roll_number,
        institute_name: user.institute_name,
        employee_id: user.employee_id,
        managed_institutes: user.managed_institutes
      }));
      
      setUsers(transformedUsers);
      setLoading(false);
    };
    
    fetchData();
    setAvailableBatches(["Batch A - 2025", "Batch C - 2026"]);
  }, []);
  
    useEffect(() => {
        if (success || error) {
            const timer = setTimeout(() => {
                setSuccess(null);
                setError(null);
            }, 5000);
            return () => clearTimeout(timer);
        }
    }, [success, error]);


  // --- Dynamic Table Filters Definition ---
  const userFilterDefinitions = useMemo(() => {
      const roleOptions = ["Admin", "Teacher", "Super Admin", "Student"].map(role => ({ value: role, label: role }));
      roleOptions.unshift({ value: '', label: 'All Roles' });

      const statusOptions = ["Active","Suspended", "Pending"].map(status => ({ value: status, label: status }));
      statusOptions.unshift({ value: '', label: 'All Statuses' });
      
      const batchOptions = availableBatches.map(batch => ({ value: batch, label: batch }));
      batchOptions.unshift({ value: '', label: 'All Batches' });

      const institutionOptions = institutions.map(inst => ({ 
        value: inst.institute_name || inst.institution_name, 
        label: inst.institute_name || inst.institution_name 
      }));
      institutionOptions.unshift({ value: '', label: 'All Institutions' });

      const definitions = { role: roleOptions, status: statusOptions };
      if (filters.role === 'Student') {
        definitions.institution = institutionOptions;
      }
      if (filters.role === 'Admin') {
        definitions.institution = institutionOptions;
      }
      return definitions;
  }, [availableBatches, institutions, filters.role]);
  
  const handleFilterChange = (key, value) => {
    const newValue = value === '' ? null : value;
    setFilters((prev) => {
        const newFilters = { ...prev, [key]: newValue };
        if (key === 'role') {
          // Reset batch if role is not Student
          if (newValue !== 'Student') newFilters.batch = null;
          // Reset institution if role is not Student or Admin
          if (newValue !== 'Student' && newValue !== 'Admin') newFilters.institution = null;
        }
        return newFilters;
    });
  };
  
  const filteredUsers = useMemo(() => {
      return users.filter((user) => {
        const matchesRole = filters.role ? user.role?.toLowerCase() === filters.role.toLowerCase() : true;
        const matchesStatus = filters.status ? user.status?.toLowerCase() === filters.status.toLowerCase() : true;
        const matchesBatch = filters.batch ? user.batch === filters.batch : true;
        const matchesInstitution = filters.institution ? 
          (user.institute_name === filters.institution || 
           user.managed_institutes?.includes(filters.institution)) : true;
        return matchesRole && matchesStatus && matchesBatch && matchesInstitution;
      });
  }, [users, filters]);
  
  const filteredUsersForTable = useMemo(() => {
      const lowerCaseSearch = searchTerm.toLowerCase();
      return filteredUsers.filter((user) => {
        return (
            user.username?.toLowerCase().includes(lowerCaseSearch) ||
            user.fullName?.toLowerCase().includes(lowerCaseSearch) ||
            user.email?.toLowerCase().includes(lowerCaseSearch)
        );
      }).map(user => ({
          ...user,
          full_name: user.full_name || user.fullName || 'N/A',
          username: user.username || 'N/A',
          email: user.email || 'N/A',
          role: user.role || 'N/A',
          phone: user.phone || 'N/A',
          // Role-specific fields
          roll_number: user.roll_number || user.rollNumber || 'N/A',
          institute_name: user.institute_name || user.instituteName || 'N/A',
          employee_id: user.employee_id || user.employeeId || 'N/A',
          managed_institutes: user.managed_institutes || user.managedInstitutes || 'N/A',
          id: user.user_id 
      }));
  }, [filteredUsers, searchTerm]);
  
  const mappedUsersForExport = useMemo(() => users.map(user => ({
        ...user,
        full_name: user.full_name || user.fullName || 'N/A',
        username: user.username || 'N/A',
        email: user.email || 'N/A',
        role: user.role || 'N/A',
        phone: user.phone || 'N/A',
        // Role-specific fields
        roll_number: user.roll_number || user.rollNumber || 'N/A',
        institute_name: user.institute_name || user.instituteName || 'N/A',
        employee_id: user.employee_id || user.employeeId || 'N/A',
        managed_institutes: user.managed_institutes || user.managedInstitutes || 'N/A',
        id: user.user_id 
  })), [users]);
  
  // Dynamic columns based on selected role filter
  const dynamicColumns = useMemo(() => {
    return getUserColumns(filters.role);
  }, [filters.role]);

  const handleDynamicTableSearch = (query) => setSearchTerm(query);
  const getUserFromRow = (row) => users.find(u => u.user_id === row.id);

  const handleBatchSuspend = (action) => {
      if (selectedUsers.length === 0) {
          alert(`Please select users to ${action}.`);
          return;
      }
      const usersToActOn = users.find(u => selectedUsers.includes(u.user_id));
      if (usersToActOn) setSuspendPopup({ open: true, user: usersToActOn });
  };
  
  const handleDeleteUser = async (userRow) => {
    const id = userRow.id; 
    const userToDelete = users.find(u => u.user_id === id);
    
    if(!userToDelete) {
      setError("User not found.");
      return;
    }
    
    if(window.confirm(`Are you sure you want to permanently delete ${userToDelete.username} (${userToDelete.role})? This action cannot be undone.`)) {
        setError(null);
        setSuccess(null);
        setIsSubmitting(true);

        try {
            // Call the delete API
            const { error: deleteError } = await deleteUser(id);
            
            if (deleteError) {
              // Check for foreign key constraint errors
              if (deleteError.code === '23503' || deleteError.message?.includes('foreign key')) {
                const errorMsg = `Cannot delete ${userToDelete.username}: This user is linked to other records (${deleteError.details || 'classes, attendance, marks, etc.'}). Please remove those associations first.`;
                alert(`❌ ${errorMsg}`);
                setError(`❌ ${errorMsg}`);
              } else if (deleteError.code === '42501') {
                const errorMsg = `Permission denied: You don't have sufficient privileges to delete this user.`;
                alert(`❌ ${errorMsg}`);
                setError(`❌ ${errorMsg}`);
              } else {
                const errorMsg = `Failed to delete user: ${deleteError.message || 'Unknown error occurred'}`;
                alert(`❌ ${errorMsg}`);
                setError(`❌ ${errorMsg}`);
              }
              throw deleteError;
            }
            
            // Remove from local state on success
            setUsers((prev) => prev.filter((user) => user.user_id !== id));
            setSuccess(`✅ ${userToDelete.role} (${userToDelete.username}) deleted successfully!`);
            
        } catch (err) {
            console.error('Delete user error:', err);
            // Error already set above
        } finally {
            setIsSubmitting(false);
        }
    }
  };

  const handleSave = async (formData, mode) => {
    setError(null);
    setSuccess(null);
    setIsSubmitting(true);
    
    const isUpdate = mode === 'edition';
    const roleToSave = isUpdate ? (editUser?.role || formData.role) : selectedRole;

    try {
        if (isUpdate) {
            // Update existing user - split data between Users table and entity tables
            const userData = {
                full_name: formData.full_name,
                email: formData.email,
                phone: formData.phone,
                username: formData.username,
                is_active: formData.is_active !== undefined ? formData.is_active : true,
                notes: formData.notes || null,
                suspension_reason: formData.suspension_reason || null,
                suspension_start: formData.suspension_start || null,
                suspension_end: formData.suspension_end || null
            };

            // Only include password if it's provided
            if (formData.password && formData.password.trim() !== '') {
                userData.password = formData.password;
            }

            let result;
            const userId = editUser.user_id;
            
            switch (roleToSave) {
                case 'Student': {
                    const studentData = {
                        roll_number: formData.roll_number,
                        institute_id: formData.institute
                    };
                    result = await updateStudent(userId, userData, studentData);
                    break;
                }
                
                case 'Teacher': {
                    const teacherData = {
                        employee_id: formData.employee_id
                    };
                    result = await updateTeacher(userId, userData, teacherData);
                    break;
                }
                
                case 'Admin': {
                    const adminData = {
                        employee_id: formData.employee_id
                    };
                    const instituteIds = formData.institutes_managed || [];
                    result = await updateAdmin(userId, userData, adminData, instituteIds);
                    break;
                }
                
                case 'Super Admin': {
                    const superAdminData = {
                        employee_id: formData.employee_id
                    };
                    result = await updateSuperAdmin(userId, userData, superAdminData);
                    break;
                }
                
                default:
                    throw new Error('Invalid role for update');
            }

            if (result.error) {
                throw new Error(result.error.message || 'Failed to update user');
            }

            // Update local state
            const savedUser = {
                ...editUser,
                ...formData,
                fullName: formData.full_name,
                user_id: userId,
                id: userId,
                role: roleToSave,
                is_active: userData.is_active,
                status: userData.is_active ? 'Active' : 'Suspended'
            };
            
            setUsers((prev) => prev.map((user) => user.user_id === userId ? savedUser : user));
            setSuccess(`✅ ${roleToSave} (${formData.username}) Updated Successfully!`);
            setEditUser(null);
            
        } else {
            // Create new user - split data between Users table and entity tables
            const userData = {
                full_name: formData.full_name,
                email: formData.email,
                phone: formData.phone,
                username: formData.username,
                password: formData.password,
                role: roleToSave,
                is_active: formData.is_active !== undefined ? formData.is_active : true,
                notes: formData.notes || null,
                suspension_reason: formData.suspension_reason || null,
                suspension_start: formData.suspension_start || null,
                suspension_end: formData.suspension_end || null
            };

            let result;
            
            switch (roleToSave) {
                case 'Student': {
                    const studentData = {
                        roll_number: formData.roll_number,
                        institute_id: formData.institute // This should be UUID from form
                    };
                    result = await createStudent(userData, studentData);
                    break;
                }
                
                case 'Teacher': {
                    const teacherData = {
                        employee_id: formData.employee_id
                    };
                    result = await createTeacher(userData, teacherData);
                    break;
                }
                
                case 'Admin': {
                    const adminData = {
                        employee_id: formData.employee_id
                    };
                    const instituteIds = formData.institutes_managed || [];
                    result = await createAdmin(userData, adminData, instituteIds);
                    break;
                }
                
                case 'Super Admin': {
                    const superAdminData = {
                        employee_id: formData.employee_id
                    };
                    result = await createSuperAdmin(userData, superAdminData);
                    break;
                }
                
                default:
                    throw new Error('Invalid role selected');
            }

            if (result.error) {
                throw new Error(result.error.message || 'Failed to create user');
            }

            // Add to local state for display
            const savedUser = {
                ...formData,
                role: roleToSave,
                user_id: result.data.user?.user_id || Date.now(),
                id: result.data.user?.user_id || Date.now(),
                is_active: userData.is_active,
                status: userData.is_active ? 'Active' : 'Suspended', // Display value
                fullName: formData.full_name,
                last_login: new Date().toISOString()
            };
            
            setUsers((prev) => [savedUser, ...prev]);
            setSuccess(`✅ ${savedUser.role} Created Successfully! Username: ${savedUser.username}`);
            setSelectedRole(null); 
        }
        
    } catch (err) {
        console.error('Error saving user:', err);
        const errorMessage = err.message || `Failed to ${isUpdate ? 'update' : 'create'} user.`;
        setError(`❌ ${errorMessage}`);
    } finally {
        setIsSubmitting(false);
        setFormSource(null);
    }
  };

  const handleSuspendSave = async ({ user_id, action, reason, timeline }) => {
    setError(null);
    setSuccess(null);
    setIsSubmitting(true);
    const userToUpdate = users.find(u => u.user_id === user_id);
    const actionText = action === "suspend" ? "Suspend" : "Reactivate";

    if (!userToUpdate) {
        setIsSubmitting(false);
        return;
    }
    
    try {
        let result;
        
        if (action === "suspend") {
            // Suspend user with reason and timeline
            const suspensionData = {
                suspension_reason: reason,
                suspension_start: timeline.startDate || null,
                suspension_end: timeline.endDate || null
            };
            
            result = await updateUserSuspension(user_id, suspensionData);
        } else {
            // Reactivate user
            result = await reactivateUser(user_id);
        }
        
        if (result.error) {
            throw new Error(result.error.message || `Failed to ${action} user`);
        }
        
        // Update local state with the returned data
        const updatedUser = {
            ...userToUpdate,
            is_active: result.data.is_active,
            status: result.data.is_active ? "Active" : "Suspended",
            suspensionReason: result.data.suspension_reason,
            suspension_start: result.data.suspension_start,
            suspension_end: result.data.suspension_end
        };
        
        setUsers(prev => prev.map(user => user.user_id === user_id ? updatedUser : user));
        setSuccess(`✅ User (${userToUpdate.username}) ${actionText}ed Successfully!`);
    } catch (err) {
        console.error(`Error ${action}ing user:`, err);
        setError(`❌ Failed to ${action} user: ${err.message}`);
    } finally {
        setIsSubmitting(false);
    }
  };

  const handleDataImported = async (importedJson) => {
      if (!importedJson || importedJson.length === 0) {
          alert("Import file is empty.");
          return;
      }
      
      setError(null);
      setSuccess(null);
      
      // Validate and transform imported data
      const validatedData = [];
      const errors = [];
      
      for (let i = 0; i < importedJson.length; i++) {
          const row = importedJson[i];
          const rowNum = i + 1;
          
          // Required fields validation
          if (!row.full_name || !row.email || !row.phone || !row.username || !row.password || !row.role) {
              errors.push(`Row ${rowNum}: Missing required fields (full_name, email, phone, username, password, role)`);
              continue;
          }
          
          // Role validation
          const validRoles = ['Student', 'Teacher', 'Admin', 'Super Admin'];
          if (!validRoles.includes(row.role)) {
              errors.push(`Row ${rowNum}: Invalid role '${row.role}'. Must be one of: ${validRoles.join(', ')}`);
              continue;
          }
          
          // Role-specific validation
          if (row.role === 'Student' && (!row.roll_number || !row.institute_id)) {
              errors.push(`Row ${rowNum}: Student requires roll_number and institute_id`);
              continue;
          }
          
          if ((row.role === 'Teacher' || row.role === 'Admin' || row.role === 'Super Admin') && !row.employee_id) {
              errors.push(`Row ${rowNum}: ${row.role} requires employee_id`);
              continue;
          }
          
          if (row.role === 'Admin' && !row.institutes_managed) {
              errors.push(`Row ${rowNum}: Admin requires institutes_managed`);
              continue;
          }
          
          // Format institutes_managed for Admin (convert string to array)
          let institutesManaged = [];
          if (row.role === 'Admin' && row.institutes_managed) {
              if (typeof row.institutes_managed === 'string') {
                  // Split by semicolon or comma
                  institutesManaged = row.institutes_managed.split(/[;,]/).map(id => id.trim()).filter(id => id);
              } else if (Array.isArray(row.institutes_managed)) {
                  institutesManaged = row.institutes_managed;
              }
          }
          
          validatedData.push({
              ...row,
              institutes_managed: institutesManaged,
              is_active: row.is_active !== undefined ? row.is_active : true,
              notes: row.notes || null,
              suspension_reason: row.suspension_reason || null
          });
      }
      
      // Show validation errors if any
      if (errors.length > 0) {
          const errorMsg = `Import validation failed:\n${errors.join('\n')}`;
          alert(errorMsg);
          setError(`❌ Import validation failed. ${errors.length} error(s) found.`);
          return;
      }
      
      // Process validated data - create users one by one
      setIsSubmitting(true);
      const successfulImports = [];
      const failedImports = [];
      
      for (let i = 0; i < validatedData.length; i++) {
          const row = validatedData[i];
          const rowNum = i + 1;
          
          try {
              const userData = {
                  full_name: row.full_name,
                  email: row.email,
                  phone: row.phone,
                  username: row.username,
                  password: row.password,
                  role: row.role,
                  is_active: row.is_active,
                  notes: row.notes,
                  suspension_reason: row.suspension_reason,
                  suspension_start: row.suspension_start || null,
                  suspension_end: row.suspension_end || null
              };
              
              let result;
              
              switch (row.role) {
                  case 'Student': {
                      const studentData = {
                          roll_number: row.roll_number,
                          institute_id: row.institute_id
                      };
                      result = await createStudent(userData, studentData);
                      break;
                  }
                  
                  case 'Teacher': {
                      const teacherData = {
                          employee_id: row.employee_id
                      };
                      result = await createTeacher(userData, teacherData);
                      break;
                  }
                  
                  case 'Admin': {
                      const adminData = {
                          employee_id: row.employee_id
                      };
                      result = await createAdmin(userData, adminData, row.institutes_managed);
                      break;
                  }
                  
                  case 'Super Admin': {
                      const superAdminData = {
                          employee_id: row.employee_id
                      };
                      result = await createSuperAdmin(userData, superAdminData);
                      break;
                  }
              }
              
              if (result.error) {
                  throw new Error(result.error.message || 'Failed to create user');
              }
              
              // Add to local state
              const newUser = {
                  user_id: result.data.user?.user_id,
                  id: result.data.user?.user_id,
                  username: row.username,
                  fullName: row.full_name,
                  email: row.email,
                  phone: row.phone,
                  role: row.role,
                  is_active: row.is_active,
                  status: row.is_active ? 'Active' : 'Suspended',
                  last_login: null,
                  notes: row.notes
              };
              
              successfulImports.push(newUser);
              
          } catch (err) {
              console.error(`Error importing row ${rowNum}:`, err);
              failedImports.push({
                  row: rowNum,
                  username: row.username,
                  error: err.message
              });
          }
      }
      
      // Update state with successful imports
      if (successfulImports.length > 0) {
          setUsers((prev) => [...successfulImports, ...prev]);
      }
      
      // Show results
      if (failedImports.length === 0) {
          setSuccess(`✅ Successfully imported ${successfulImports.length} user(s)!`);
      } else {
          const failedMsg = failedImports.map(f => `Row ${f.row} (${f.username}): ${f.error}`).join('\n');
          alert(`Import completed with errors:\n\nSuccessful: ${successfulImports.length}\nFailed: ${failedImports.length}\n\nErrors:\n${failedMsg}`);
          setError(`⚠️ Imported ${successfulImports.length} user(s). ${failedImports.length} failed.`);
      }
      
      setIsSubmitting(false);
  };
  
  const handlePendingUserStatusChange = (userRow, newStatus) => {
      const userToProcess = pendingUsers.find(u => u.id === userRow.id);
      if (!userToProcess) return;

      if (newStatus === 'Approved') {
          const activatedUser = {
              ...userToProcess,
              is_active: true,
              status: 'Active', // Display value
              user_id: Date.now(), 
              id: Date.now(),
              last_login: new Date().toISOString(),
              suspensionReason: null,
          };
          setUsers(prev => [activatedUser, ...prev]);
          setPendingUsers(prev => prev.filter(u => u.id !== userRow.id));
          setSuccess(`User ${activatedUser.username} approved.`);
      } else if (newStatus === 'Rejected') {
          setPendingUsers(prev => prev.filter(u => u.id !== userRow.id));
          setSuccess(`Pending user ${userToProcess.username} was rejected.`);
      }
  };

  const handleOpenCreateUser = (role) => {
    setEditUser(null);
    setFormSource(null); 
    setSelectedRole(role);
    setError(null); 
    setSuccess(null);
  };
  
  const handleOpenEditUser = async (userRow) => {
    const user = getUserFromRow(userRow); 
    if(!user) return;
    
    setError(null); 
    setSuccess(null);
    
    try {
      let roleSpecificData = {};
      
      // Fetch role-specific data
      switch(user.role) {
        case 'Student': {
          const { data: studentData, error: studentError } = await getStudentByUserId(user.user_id);
          if (studentError) throw studentError;
          if (studentData) {
            roleSpecificData = {
              roll_number: studentData.roll_number,
              institute: studentData.institute_id
            };
          }
          break;
        }
        
        case 'Teacher': {
          const { data: teacherData, error: teacherError } = await getTeacherByUserId(user.user_id);
          if (teacherError) throw teacherError;
          if (teacherData) {
            roleSpecificData = {
              employee_id: teacherData.employee_id
            };
          }
          break;
        }
        
        case 'Admin': {
          const { data: adminData, error: adminError } = await getAdminByUserId(user.user_id);
          if (adminError) throw adminError;
          if (adminData) {
            roleSpecificData = {
              employee_id: adminData.employee_id,
              institutes_managed: adminData.admin_institutions?.map(ai => ai.institute_id) || []
            };
          }
          break;
        }
        
        case 'Super Admin': {
          const { data: superAdminData, error: superAdminError } = await getSuperAdminByUserId(user.user_id);
          if (superAdminError) throw superAdminError;
          if (superAdminData) {
            roleSpecificData = {
              employee_id: superAdminData.employee_id
            };
          }
          break;
        }
        
        default:
          break;
      }
      
      // Combine user data with role-specific data
      const combinedUserData = {
        ...user,
        ...roleSpecificData
      };
      
      setSelectedRole(null); 
      setFormSource("action"); 
      setEditUser(combinedUserData);
      
    } catch (err) {
      console.error('Error loading user data for edit:', err);
      setError(`❌ Failed to load user data: ${err.message || 'Unknown error'}`);
    }
  };
  
  const handleSuspendReactivateAction = (userRow) => {
      const user = getUserFromRow(userRow);
      if (user) setSuspendPopup({ open: true, user: user });
  };


  return (
    <div className="user-management">
        
      {/* Success/Error Notifications */}
      {success && (
        <div className="notification success-notification">
          <FiCheckCircle className="notification-icon" />
          <span>{success}</span>
          <FiX className="close-icon" onClick={() => setSuccess(null)} />
        </div>
      )}
      
      {error && (
        <div className="notification error-notification">
          <FiAlertTriangle className="notification-icon" />
          <span>{error}</span>
          <FiX className="close-icon" onClick={() => setError(null)} />
        </div>
      )}
        
      <div className="um-header">
        <h2 className="page-title">User Management</h2>
        <div className="um-actions">
          {selectedUsers.length > 0 && (
              <div className="batch-actions-group">
                  <span className="selected-count">{selectedUsers.length} Selected:</span>
                  <button className="btn btn-danger" onClick={() => handleBatchSuspend("suspend")}>
                      <RiUserForbidFill /> Suspend Batch
                  </button>
                  <button className="btn btn-primary" onClick={() => handleBatchSuspend("reactivate")}>
                      <FiCheckCircle /> Reactivate Batch
                  </button>
              </div>
          )}
          <button className="btn btn-primary" onClick={() => handleOpenCreateUser("Student")}>
            <FiPlus /> Add Student
          </button>
          <button className="btn btn-primary" onClick={() => handleOpenCreateUser("Teacher")}>
            <FiPlus /> Add Teacher
          </button>
          <button className="btn btn-primary" onClick={() => handleOpenCreateUser("Admin")}>
            <FiPlus /> Add Admin
          </button>
          <button className="btn btn-primary" onClick={() => handleOpenCreateUser("Super Admin")}>
            <FiPlus /> Add Super Admin
          </button>
        </div>
      </div>

      <div className="summary-cards">
        <div className="summary-card">
          <h4>Total Users</h4>
          <p className="summary-value">{users.length}</p>
        </div>
        {pendingUsers.length > 0 && (
            <div className="summary-card warning">
                <h4>Pending Imports</h4>
                <p className="summary-value">{pendingUsers.length}</p>
            </div>
        )}
        {(searchTerm || filters.role || filters.status || filters.batch || filters.institution) && (
          <div className="summary-card">
            <h4>Filtered Results</h4>
            <p className="summary-value">{filteredUsersForTable.length}</p> 
          </div>
        )}
      </div>

      {/* --- INTEGRATED DYNAMIC FORM --- */}
      {(selectedRole || editUser) && (
          <DynamicForm
            isOpen={true}
            mode={editUser ? 'edition' : 'creation'}
            fieldsConfig={getUserRoleConfig(editUser ? editUser.role : selectedRole, instituteOptions, !!editUser)}
            initialData={editUser ? {
              ...editUser,
              full_name: editUser.fullName // Map fullName back to full_name for form
            } : {}}
            onClose={() => {
              setSelectedRole(null);
              setEditUser(null);
            }}
            onSubmit={handleSave}
          />
      )}
      
      {suspendPopup.open && suspendPopup.user && (
        <SuspendUserModal
            user={suspendPopup.user}
            onClose={() => setSuspendPopup({ open: false, user: null })}
            onSave={handleSuspendSave}
        />
      )}

      {loading ? (
        <div className="loading-state">
          <div className="spinner"></div>
          <p>Loading users...</p>
        </div>
      ) : (
          <>
            {pendingUsers.length > 0 && (
                <div className="pending-users-section">
                    <DynamicTable
                        data={pendingUsers}
                        columnOrder={PENDING_USER_COLUMN_ORDER}
                        title="Pending Imported Users"
                        onStatusChange={handlePendingUserStatusChange} 
                        pillColumns={['status', 'role']}
                        customDescription="Approve or Reject the imported users below."
                    />
                </div>
            )}
            <DynamicTable
                data={filteredUsersForTable}
                unfilteredData={mappedUsersForExport} 
                onDataImported={handleDataImported}   
                columnOrder={dynamicColumns}
                title="All Users"
                onEdit={handleOpenEditUser} 
                onDelete={handleDeleteUser} 
                hasSuspension={true}
                onSuspendReactivate={handleSuspendReactivateAction}
                onSearch={handleDynamicTableSearch}
                filterDefinitions={userFilterDefinitions}
                activeFilters={Object.fromEntries(
                    Object.entries(filters).filter(([, v]) => v !== null).map(([k, v]) => [k, v])
                )}
                onFilterChange={handleFilterChange}
                pillColumns={['status', 'role']} 
            />
          </>
      )}
    </div>
  );
};

export default UserManagement;